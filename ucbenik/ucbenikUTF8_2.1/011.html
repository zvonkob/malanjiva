<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
   PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="sl" lang="sl">
<head>
   <title>Akcija</title>
   <link rel="stylesheet" type="text/css"
         href="oblika.css"
         title="Ucbenik" />
   <script language="javascript" type="text/javascript" src="funkcije.js">
   </script>
</head>
<body>
<h1>Akcija</h1>
   <p>
   Tako. Prisopihali smo do zadnjega poglavja in takoj na začetku naj vas potolažim, da v njem ne bo več ničesar novega, vsaj kar se tiče tehnologije. Namesto tega se bomo dotaknili veliko zanimivejše tematike, to je načrtovanje spletnih strani. Področje načrtovanja spletnih aplikacij je zelo obsežno in zahtevno. Poleg tega doživlja krizo, podobno softverski krizi konca šestdesetih let prejšnjega stoletja, preden so se pojavili prvi strukturirani programski jeziki. Ogromno o načrtovanju spletnih strani in aplikacij bo našel bralec v ustrezni <a href="110.html">literaturi</a>, v tem poglavju bom ponudil le nekaj malega za aromo. Prikazal vam bom dva zelo preprosta primera dinamičnih spletnih strani. V prvem primeru bomo načrtovali preprost generator kombinacije za Loto. Kdo ve, morda bo kdo z njegovo pomočjo postal milijonar! Drugi primer bo večini dobro znana igrica Spomin, v kateri skušajo igralci odkriti pare enakih sličic. 
   </p>
   <p>
   Ker se v tem poglavju ukvarjamo z načrtovanjem, je vsak od primerov dostopen v večih datotekah, od katerih predstavlja vsaka svojo stopnjo razvoja istega primera. Datoteke je moč dobiti na začetku posameznih razdelkov v stisnjeni obliki.
   </p>
   <h2>Kombinacija za Loto<br />(<a href="./nacrtovanje/Loto.zip">Loto.zip</a>)</h2>
   <p>
   Pravila za igranje Lota dovoljujejo vplačila kombinacij dolžine od 7 pa do 17 številk, pri čemer izbiramo številke med 1 in 39. Spletna stran, ki jo bomo sestavili v tem razdelku, bo uporabniku omogočila, da izbere, koliko številk želi odkrižati na lističu, in da si generira poljubno različnih kombinacij izbrane dolžine.
   </p>
   <p>
   V prvem koraku načrtovanja (Loto1.html) naše spletne strani si bomo zamislili izgled strani. Na strani mora biti najprej nekaj osnovnih napotkov, ki uporabniku razložijo, kaj mu stran ponuja in kako deluje. Druga stvar, ki jo bomo imeli na naši strani, je nek vnosni element, prek katerega bo uporabnik vnesel dolžino kombinacije. Če bi bil ta vnosni element polje za vnos besedila, si lahko kot programerji nakopljemo težave, saj moramo predvideti, da lahko uporabnik (namerno ali nenamerno) vanj vnese karkoli in ne le cela števila med 7 in 17. Da nam ne bo potrebno pisati kode za preverjanje vnešene vrednosti, bomo uporabili raje izbirni seznam, s katerim uporabnika zelo enostavno omejimo na želene vrednosti. Poleg izbirnega seznama potrebujemo še gumb, ki bo sprožil postopek generiranja številk. Na koncu dodamo še element, v katerem se bodo številke izpisale. Uporabili bomo kar urejevalno polje. 
   </p>
   <p>
   Čeprav moramo v prvem koraku načrtovanja že misliti na to, kako bo stran delovala, pa na tej stopnji tega še ne uresničimo. Na sliki 4 vidimo, kako bo stran izgledala.
   </p>
   <table style="border-width:0;" width="501">
   <tr><td>
   <img src="./slike/Loto1.gif" alt="Izgled generatorja" title="Izgled generatorja" />
   </td></tr>
   <tr><td>
   Slika 4: <em>V prvem koraku načrtovanja si zamislimo izgled strani.</em>
   </td></tr>
   </table>
   <p>
   V drugem koraku moramo poskrbeti, da se bo ob kliku na gumb izvedel upravljalnik dogodka, v katerem se bo v resnici vse dogajalo. Gumbu zato dodamo lastnost <kbd>onclick</kbd> in mu priredimo klic funkcije, ki opravlja vlogo upravljalnika dogodka:
   </p>
   <pre>
      onclick="generiraj()"
   </pre>
   <p>
   Funkcijo <kbd>generiraj()</kbd> napišemo v glavi dokumenta v elementu <kbd>script</kbd>. V drugem koraku se bomo zadovoljili s tem, da se bo generiralo in izpisalo toliko naključnih številk med 1 in 39, kolikor jih uporabnik želi. Ne bo nas še motilo, če se številke ponavljajo, ali če niso urejene po velikosti.
   </p>
   <p>
   Takole je videti funkcija, s katero to dosežemo:
   </p>
   <pre>
      function generiraj()
      {
         var i, n;
         var kombinacija = new Array();
         n = document.getElementById("st_komb").value;
         
         for (i = 0; i &lt; n; i++)
         {
            kombinacija[i] = Math.floor(Math.random() * 38.99999) + 1;      
         }
         
         document.getElementById("izpis").value = kombinacija.join(" ");
      }
   
   </pre>
   <p>
   V prvih dveh vrsticah kode deklariramo nekaj spremenljivk, ki jih bomo v funkciji potrebovali. V tretji vrstici nam postopek <kbd>getElementById()</kbd> priskrbi sklic na objekt, ki predstavlja izbirni seznam. Zanima nas, katera postavka je bila v času pritiska na gumb izbrana, zato izberemo lastnost <kbd>value</kbd> in njeno vrednost priredimo spremenljivki <var>n</var>. Ta spremenljivka odslej hrani podatek o tem, koliko števil je potrebno generirati. Tretja vrstica je zapisana v nekoliko strnjeni obliki. Z naslednjim zapisom dosežemo isto:
   </p>
   <pre>
      var izbira = document.getElementById("st_komb");   
      n = izbira.value;
   </pre>
   <p>
   Vhodni podatek imamo. Zdaj lahko v ponavljalnem stavku <kbd>for</kbd> izračunamo <var>n</var> različnih naključnih številk in jih priredimo elementom od <kbd>kombinacija[0]</kbd> do <kbd>kombinacija[n-1]</kbd>. Posamezno številko izračunamo tako, da vrednost, ki jo vrne postopek <kbd>random()</kbd> pomnožimo z 38.99999 in dobljeno vrednost podamo postopku <kbd>floor()</kbd>. Slednji vrednost zaokroži navzdol, tako da dobimo številke med 0 in 38. Temu na koncu prištejemo 1 in dobimo številke, ki so lahko le med 1 in 39. Če bi namesto z 38.99999 množili z 39, bi se lahko na koncu sem in tja pojavila tudi vrednost 40. Razmislite, zakaj!
   </p>
   <p>
   V zadnji vrstici  priredimo izbrano kombinacijo lastnosti <kbd>value</kbd> objekta, ki predstavlja urejevalno polje. Elemente kombinacije smo združili s postopkom <kbd>join()</kbd>, ker smo želeli, da so izbrane številke ločene s presledki. Na sliki 5 vidimo primer delovanja naše strani po končanem drugem koraku načrtovanja.
   </p>
   <table style="border-width:0;" width="502">
   <tr><td>
   <img src="./slike/Loto2.gif" alt="Številke se ponavljajo in niso urejene" title="Številke se ponavljajo in niso urejene" />
   </td></tr>
   <tr><td>
   Slika 5: <em>V drugem koraku generator že deluje, vendar se izbrane številke ponavljajo in niso urejene po velikosti. Številka 12 se je pojavila celo trikrat.</em>
   </td></tr>
   </table>
   <p>
   V tretjem koraku (Loto3.html) bomo poskrbeli, da se bodo številke izpisale urejene po velikosti. Urejanje po velikosti ni prevelik problem, saj ima objekt <kbd>Array</kbd> vgrajeno metodo <kbd>sort()</kbd>, ki uredi elemente zbirke. Problem je le ta, da se elementi uredijo po abecedi. V našem primeru to pomeni, da bi se številke 2, 11, in 30 uredile v napačnem vrstnem redu 11, 2 in 30. Problem preprosto rešimo tako, da vsem izbranim številkam pred urejanjem prištejemo konstantno vrednost 9, ki jo pred izpisom spet odštejemo. Tako zdaj urejamo številke med 10 in 49, ki si tudi po abecedi sledijo v pravilnem vrstnem redu.
   </p>
   <p>
   Da to dosežemo, moramo v naši funkciji spremeniti vrstico znotraj zanke <kbd>for</kbd> v
   </p>
   <pre>
      kombinacija[i] = Math.floor(Math.random() * 38.99999) + 10;      
   </pre>
   <p>
   Razlika je v tem, da na koncu ne prištevamo 1, ampak 10. Med zanko <kbd>for</kbd> in izpisom izbranih številk dodamo še urejanje in še eno zanko <kbd>for</kbd>, v kateri vsem izbranim številkam odštejemo konstantno vrednost 9, da končno spet dobimo števila med 1 in 39:
   </p>
   <pre>
      kombinacija.sort();
      for (i = 0; i &lt; n; i++)
      {
         kombinacija[i] -= 9;      
      }
   </pre>
   <p>
   Na sliki 6 vidimo, da so zdaj številke urejene po velikosti.
   </p>
   <table style="border-width:0;" width="502">
   <tr><td>
   <img src="./slike/Loto3.gif" alt="Številke so zdaj urejene" title="Številke so zdaj urejene" />
   </td></tr>
   <tr><td>
   Slika 6: <em>V tretjem koraku se izbrane številke še vedno ponavljajo, so pa že urejene po velikosti.</em>
   </td></tr>
   </table>
   <p>
   Ostal nam je še zadnji korak načrtovanja (Loto4.html), v katerem se bomo znebili ponavljanja. Poskrbeti moramo samo za to, da vsakokrat, ko izberemo novo številko, preverimo, če ta številka slučajno že ne obstaja. Če obstaja, moramo izbiro ponoviti. Takoj za vrstico, ki elementu <kbd>kombinacija[i]</kbd> priredi naključno vrednost, dodamo še en stavek <kbd>for</kbd>:
   </p>
   <pre>
      kombinacija[i] = Math.floor(Math.random() * 38.99999) + 10;      
      for (j = 0; j &lt; i; j++)
      {
         if (kombinacija[i] == kombinacija[j])
         {
            i--;
            break;
         }
      }
   </pre>
   <p>
   V dodani zanki <kbd>for</kbd> primerjamo vse doslej izbrane številke (<kbd>kombinacija[j]</kbd>) s številko, ki smo jo pravkar izbrali (<kbd>kombinacija[i]</kbd>). Če se primerjava izide, potem spremenljivko <var>i</var> zmanjšamo za ena in s stavkom <kbd>break</kbd> končamo primerjanje. S tem, ko smo za ena zmanjšali vrednost spremenljivke <var>i</var>, smo povzročili, da se bo naslednje izbrano število priredilo še enkrat istemu elementu. To se bo dogajalo, vse dokler se ne bo generirala številka, ki v zbirki <kbd>kombinacija</kbd> še ne obstaja. Na sliki 7 vidimo končen izdelek.
   </p>
   <table style="border-width:0;" width="502">
   <tr><td>
   <img src="./slike/Loto4.gif" alt="Generator kombinacije za Loto" title="Generator kombinacije za Loto" />
   </td></tr>
   <tr><td>
   Slika 7: <em>Končen izgled delujočega generatorja kombinacije za Loto.</em>
   </td></tr>
   </table>


   <p>
   Tako, program deluje, zdaj pa hitro do šalterja in vplačat listič! Če pa je že pozno in je že vse zaprto, lahko poizkusite za vajo dopolniti stran tako, da bo možno poleg dolžine generirane kombinacije izbrati tudi, koliko kombinacij želimo generirati (na primer od 1 do 10). Tako bo lahko uporabnik z enim samim pritiskom na tipko "Generiraj" dobil hkrati tudi do 10 kombinacij. Poizkusite doseči tudi, da se bo vsebina izbirnega seznama za število kombinacij spreminjala v odvisnosti od izbire dolžine kombinacije. Če namreč vplačujete kombinacije dolžine 7, potem morate izpolniti kombinacijski listič, ki ima 10 polj za 10 različnih kombinacij. Za daljše kombinacije morate izpolniti sistemski listič, ki pa ima le 5 polj za 5 različnih kombinacij. Torej, v primeru, da želi uporabnik kombinacije dolžine 7, mu morate v drugem izbirnem seznamu ponuditi možnosti od 1 do 10, sicer pa le od 1 do 5.
   </p>
   <h2>Spomin<br />(<a href="./nacrtovanje/Spomin.zip">Spomin.zip</a>)</h2>
   <p>
   V tej igri za enega ali več igralcev uporabljamo zbirko kart z različnimi sličicami. V zbirki so karte zastopane v parih, tako da se vsaka sličica pojavi na dveh kartah. Karte najprej premešamo in jih položimo na mizo s hrbtno stranjo navzgor. Vsakdo, ki je na potezi, obrne dve karti in če sta enaki, ju obdrži, sicer ju vrne nazaj na mizo, spet obrnjeni s hrbtom navzgor.
   </p>
   <p>
   Na spletni strani, ki jo bomo sestavili, bo mogoče igrati Spomin v obliki pasjanjse. V oknu se bodo najprej pokazale s hrbtom navzgor obrnjene karte, ki jih bo igralec s klikom miške obračal. Ko bo obrnil tretjo karto, se bosta odprti karti zaprli, če bosta njuni sličici različni, sicer bosta karti izginili. Slika 8 prikazuje stanje na začetku igre.
   </p>
   <table style="border-width:0;" width="347">
   <tr><td>
   <img src="./slike/Spomin1.gif" alt="Spomin" title="Spomin" />
   </td></tr>
   <tr><td>
   Slika 8: <em>Ko naložimo stran v okno brskalnika, so vse karte Spomina zaprte.</em>
   </td></tr>
   </table>
   <p>
   V prvem koraku (Spomin1.html) bomo spet samo oblikovali stran, funkcionalnost pa bomo postopoma dodajali v korakih, ki sledijo. Tokrat si bomo že za oblikovanje strani pomagali z jezikom JavaScript, saj bomo lahko na ta način kasneje zelo preprosto spreminjali nabor in število sličic. V telesu dokumenta najprej ustvarimo spremenljivko <var>predpona</var>, s pomočjo katere bomo lahko izbirali različne nabore sličic. Primeru sta priložena dva nabora s po 24 sličicami. Prvi nabor vsebuje različne računalniške, drugi pa športne ikone. Imena datotek, v katerih so računalniške sličice, se pričnejo s predpono <kbd>"komp_"</kbd>, tiste s športnimi sličicami pa se pričnejo s predpono "<kbd>"sport_"</kbd>". Igralne sličice so oštevilčene s številkami od 0 do 23, obstajata pa še dve posebni sličici, ena za hrbtno stran karte in druga prozorna, ki jo uporabljamo za odstranjene karte. V našem primeru bomo uporabili računalniške ikone, zato nastavimo spremenljivko <var>predpona</var> na vrednost <kbd>"komp_"</kbd>:
   </p>
   <pre>
      var predpona = "komp_";
   </pre>
   <p>
   Takoj za tem bomo klicali funkcijo <kbd>zacetnoStanje()</kbd>, ki ji podamo dva celoštevilska parametra. Prvi predstavlja število stolpcev, drugi pa število vrstic pravokotne mreže, na kateri bodo razporejene karte. S spreminjanjem teh dveh vrednosti lahko programer enostavno uravnava število in razporeditev kartic:
   </p>
   <pre>
      zacetnoStanje(4, 3);
   </pre>
   <p>
   Preostane nam samo še, da napišemo definicijo funkcije <kbd>zacetnoStanje()</kbd>. Takole izgleda:
   </p>
   <pre>
      function zacetnoStanje(stolpcev, vrstic)
      {
         var i;
         var kart = stolpcev * vrstic;
   
         document.write("&lt;table cellpadding='2'&gt;");
   
         for (i = 0; i &lt; kart; i++)
         {
            if (i % stolpcev == 0)
            {
               document.write("&lt;tr&gt;");
            }
            
            document.write("&lt;td&gt;&lt;img src='" + predpona + "ozadje.gif'");
            document.write("id='karta" + i + "' name='karta" + i + "'+ /&gt;&lt;/td&gt;");
            
            if ((i + 1) % stolpcev == 0)
            {
               document.write("&lt;/tr&gt;");
            }
   
         }
         
         document.write("&lt;/table&gt;");
      }
   </pre>
   <p>
   Hiter pogled na funkcijo nam razkrije, da bomo karte vstavili v tabelo. V funkciji najprej izračunamo število kart, tako da pomnožimo število stolpcev in vrstic, in potem v dokument vpišemo začetno značko elementa <kbd>table</kbd>. V zanki <kbd>for</kbd> za vsako karto posebej v tabelo dodamo eno celico, v katero vstavimo element <kbd>img</kbd>:
   </p>   
   <pre>
      document.write("&lt;td&gt;&lt;img src='" + predpona + "ozadje.gif'");
      document.write("id='karta" + i + "' name='karta" + i + "'+ /&gt;&lt;/td&gt;");
   </pre>
   <p>
   Lastnost <kbd>src</kbd> elementa <kbd>img</kbd> smo nastavili na ime datoteke, ki hrani hrbtno stran karte. Ime datoteke je sestavljeno iz predpone in niza <kbd>"ozadje.gif"</kbd>. Vsakemu elementu smo določili tudi svojo vrednost za <kbd>id</kbd>, ki je sestavljena iz niza <kbd>"karta"</kbd> in zaporedne številke karte. Končen zapis za celico s prvo karto izgleda takole: 
   </p>
   <pre>
      &lt;td&gt;
         &lt;img src='komp_ozadje.gif' id='karta0' name='karta0' /&gt;
      &lt;/td&gt;
   </pre>
   <p>
   Poskrbeti moramo le še za pravilno razporeditev vrstic v tabeli. To dosežemo z dvema stavkoma <kbd>if</kbd> znotraj zanke <kbd>for</kbd>. V prvem stavku <kbd>if</kbd> vstavimo značko za začetek vrstice vsakokrat, ko je ostanek deljenja zaporedne številke karte s številom stolpcev enak 0. Če imamo 12 kart razporejenih v 4 stolpce, se tako vrstice tabele pričnejo tik pred kartami 0, 4 in 8. Na podoben način dosežemo, da se značke za konec vrstice vstavijo tik za kartami 3, 7 in 11.
   </p>
   <p>
   Preden nadaljujemo, poizkusite predponi spremeniti vrednost v <kbd>"sport_"</kbd>. Spremenite tudi število vrstic in stolpcev prikaza in opazujte učinek.
   </p>
   <p>
   V prvem koraku načrtovanja smo v resnici samo razporedili in prikazali hrbtne strani kart. V drugem koraku (Spomin2.html) bomo stran dopolnili tako, da se bo ob kliku na karto prikazala sličica. Na tej stopnji se odprte karte še ne bodo zapirale ali odstranjevale.
   </p>
   <p>
   Če želimo, da se bo ob kliku na karto prikazala sličica, moramo najprej vsaki karti določiti sličico ter napisati ustrezen upravljalnik dogodka in ga povezati z vsemi kartami. V tem koraku načrtovanja bomo hkrati poskrbeli, da bodo sličice premešane. Ker v našem primeru uporabljamo 6 sličic, oštevilčenih s številkami od 0 do 5 in se vsaka sličica pojavi dvakrat, bomo za razporeditev sličic uporabili naključno generirano zbirko dvanajstih celih števil od 0 do 5 in še enkrat od 0 do 5. Na primer (1, 0, 2, 1, 3, 2, 4, 5, 5, 0, 4, 3). Takšno zbirko ustvarimo s klicem funkcije <kbd>mesaj()</kbd>, ki smo ga dodali v začetku funkcije <kbd>zacetnoStanje()</kbd>:
   </p>
   <pre>
      var zaporedjeSlik = mesaj(kart);
   </pre>
   <p>
   Definicija funkcije <kbd>mesaj()</kbd> izgleda takole: 
   </p>
   <pre>
      function mesaj(dolzina)
      {
         var karte = new Array(dolzina);
         var i, indeks;
         var tmp;
         for (i = 0; i &lt; dolzina; i++)
         {
            karte[i] = i % (dolzina / 2);
         }
         for (i = 0; i &lt; dolzina; i++)
         {
            indeks = Math.round(Math.random() * (dolzina - 1));
            tmp = karte[i];
            karte[i] = karte[indeks];
            karte[indeks] = tmp;
         }
         return karte;
      }
   
   </pre>
   <p>
   V funkciji se najprej ustvari zbirka <var>karte</var> ustrezne dolžine. V prvi zanki <kbd>for</kbd> posameznim elementom priredimo po vrsti vrednosti od 0 do <var>dolzina</var>&nbsp;/&nbsp;2&nbsp;-&nbsp;1 in še enkrat od 0 do <var>dolzina</var>&nbsp;/&nbsp;2&nbsp;-&nbsp;1. V našem konkretnem primeru šestih parov bo imela zbirka <var>karte</var> ob zaključku prvega stavka <kbd>for</kbd> vsebino (0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5). V drugi zanki <kbd>for</kbd> te vrednosti med seboj premešamo, in sicer tako, da večkrat zapored izberemo naključno vrednost, ki jo shranimo v spremenljivko <var>indeks</var>, potem pa med seboj zamenjamo elementa z indeksoma <var>indeks</var> in <var>i</var>. Funkcija na koncu vrne zbirko premešanih vrednosti, ki predstavljajo zaporedne številke kart.
   </p>
   <p>
   Zdaj moramo vsakemu elementu <kbd>img</kbd> dodati še klic upravljalnika dogodka <kbd>onclick</kbd>: 
   </p>
   <pre>
      document.write("onclick='klikNaKarto(" + i + ", " + zaporedjeSlik[i] + ")'");
   </pre>
   <p>
   Če ima na primer prvi element polja <var>zaporedjeSlik</var> vrednost 3, potem se v prvi element <kbd>img</kbd> v resnici zapiše:
   </p>
   <pre>
      onclick='klikNaKarto(0, 3)'
   </pre>
   <p>
   To pomeni, da se ob kliku na to konkretno karto kliče upravljalnik dogodka <kbd>klikNaKarto()</kbd> s parametroma 0 in 3. Prvi parameter upravljalniku pove, kateri element <kbd>img</kbd> je sprožil dogodek, drugi parameter pa pove, katero slikico je potrebno prikazati. Definicija upravljalnika dogodka na tej stopnji načrtovanja vsebuje le dve vrstici kode:
   </p>
   <pre>
      function klikNaKarto(stevKarte, stevSlike)
      {
         var karta = document.getElementById("karta" + stevKarte); 
         karta.src = predpona + stevSlike + ".gif";
      }
   </pre>
   <p>
   V prvi vrstici s postopkom <kbd>getElementById()</kbd> dobimo sklic na objekt, ki je sprožil dogodek, v drugi vrstici pa samo spremenimo lastnost <kbd>src</kbd> tega objekta in element <kbd>img</kbd> že prikazuje sličico, ki mu pripada.
   </p>
   <p>
   Slika 9 prikazuje delovanje Spomina po končanem drugem koraku načrtovanja. Kliknjene karte so odprte.
   </p>
   <table style="border-width:0;" width="347">
   <tr><td>
   <img src="./slike/Spomin2.gif" alt="S klikom odpremo karto" title="S klikom odpremo karto" />
   </td></tr>
   <tr><td>
   Slika 9: <em>V drugem koraku načrtovanja smo dosegli, da se ob kliku karta odpre. Odprta karta se nikoli ne zapre ali izgine, tudi če odpremo več kot 2 karti.</em>
   </td></tr>
   </table>
   <p>
   V zadnjem koraku (Spomin3.html) nam je preostalo še, da napišemo ustrezno kodo za zapiranje in odstranjevanje kart. V telo dokumenta najprej dodamo nekaj novih spremenljivk, ki jih bomo v ta namen potrebovali. Spomnimo se, da so to globalne spremenljivke, ki obstajajo, dokler je stran naložena:
   </p>
   <pre>
      var prviKlik = true;
      var odprtaKarta1;
      var odprtaKarta2;
   </pre>
   <p>
   Kadar kliknemo na kakšno karto, je pomembno, da vemo, ali smo kliknili prvo ali drugo karto iz para. To informacijo bo hranila spremenljivka <var>prviKlik</var>, ki bo imela vrednost <kbd>true</kbd>, dokler ne bomo kliknili prve karte. Takoj po kliku na prvo karto bo dobila vrednost <kbd>false</kbd>. To vrednost bo obdržala toliko časa, dokler ne bomo kliknili druge karte, nakar bo zopet dobila vrednost <kbd>true</kbd>. Spremenljivki <var>odprtaKarta1</var> in <var>odprtaKarta2</var> bosta hranili zaporedni številki nazadnje odprtih kart, da jih bomo lahko po potrebi odstranili ali zaprli.
   </p>
   <p>
   Takoj za prvo vrstico upravljalnika dogodka <kbd>klikNaKarto()</kbd> dodamo naslednjo kodo:
   </p>
   <pre>
      if (karta.src.indexOf("ozadje.gif") == -1) 
      {
         return; //kliknili smo odprto ali odstranjeno karto
      }
   </pre>
   <p>
   Ta koda povzroči, da v primeru, da smo kliknili na karto, ki ni zaprta, takoj zapustimo funkcijo. Igro smo namreč zasnovali tako, da lahko igralec povzroči spremembo le s klikom na zaprto karto.
   </p>
   <p>
   Na koncu funkcije <kbd>klikNaKarto()</kbd>, ko se karta že odpre, bomo dodali stavek <kbd>if..else</kbd>, s katerim poskrbimo za pravilno dogajanje v odvisnosti od tega, ali smo kliknili prvo ali drugo karto iz para:
   </p>
   <pre>
      if (prviKlik == true) //klik na prvo karto
      {
         zapriKarte();
         prviKlik = false;
         odprtaKarta1 = stevKarte;
      }
      else  //klik na drugo karto
      {
         odprtaKarta2 = stevKarte;
         prviKlik = true;
      }
   </pre>
   <p>
   Če se je dogodek sprožil s klikom na prvo karto, potem klic funkcije <kbd>zapriKarte()</kbd> najprej zapre oziroma odstrani trenutno odprt par. Definicijo funkcije <kbd>zapriKarte()</kbd> si bomo ogledali malo kasneje. Spremenljivka <var>prviKlik</var> potem preklopi vrednost na <kbd>false</kbd> in shrani se številka kliknjene karte, ki je zdaj odprta.
   </p>
   <p>
   V primeru, da se je dogodek sprožil kot posledica klika na drugo karto, si samo zapomnimo zaporedno številko druge odprte karte in preklopimo vrednost spremenljivke <var>prviKlik</var> na <kbd>true</kbd>.  
   </p>
   <p>
   Ostala nam je samo še definicija funkcije <kbd>zapriKarte()</kbd>. Takole izgleda:
   </p>
   <pre>
      function zapriKarte()
      {
         var karta1 = document.getElementById("karta" + odprtaKarta1); 
         var karta2 = document.getElementById("karta" + odprtaKarta2); 
         if (karta1 == null || karta2 == null)
         {
            return;
         }
         if (karta1.src == karta2.src)
         {
            karta1.src = predpona + "prozorna.gif";
            karta2.src = predpona + "prozorna.gif";
         }
         else
         {
            karta1.src = predpona + "ozadje.gif";
            karta2.src = predpona + "ozadje.gif";
         }
      }
   </pre>
   <p>
   V prvih dveh vrsticah si pridobimo sklic na obe kliknjeni karti. Ob čisto prvem kliku, takoj po tem, ko se stran naloži v brskalnik, spremenljivki <var>odprtaKarta1</var> in <var>odprtaKarta2</var> še nimata določenih vrednosti, zato postopek <kbd>getElementById()</kbd> vrne vrednost <kbd>null</kbd>. To se zgodi zato, ker postopek prejme parameter z vrednostjo <kbd>"kartaundefined"</kbd>, objekt s takšnim <kbd>id</kbd> pa ne obstaja. V tem primeru v prvem stavku <kbd>if</kbd> takoj izstopimo iz funkcije. V nasprotnem primeru najprej preverimo, če prikazujeta obe odprti karti isto sličico in če jo, potem karti odstranimo. Karti odstranimo tako, da jima priredimo ime datoteke s prozorno sliko, ki se v oknu ne bo videla. Če odprti karti prikazujeta različni sličici, ju zapremo, tako da jima priredimo sliki ozadja.
   </p>
   <p>
   Slika 10 prikazuje delujočo stran, kjer je nekaj parov že odkritih in odstranjenih.
   </p>
   
   <table style="border-width:0;" width="347">
   <tr><td>
   <img src="./slike/Spomin3.gif" alt="Delujoč Spomin" title="Delujoč Spomin" />
   </td></tr>
   <tr><td>
   Slika 10: <em>Stran zdaj deluje. Odkriti pari so odstranjeni.</em>
   </td></tr>
   </table>

   <p>
   Delo programerja v resnici nikoli ni končano, saj se sproti porajajo nove in nove ideje. Poizkusite strani, ki smo jo pravkar izdelali, dodat nekatere izboljšave:
   </p>
   <ul>
      <li><em>Možnost izbire števila parov.</em> Pri tem morate paziti, da ne bo mogoče izbrati več parov, kot je na voljo sličic. Razmislite tudi, kako rešiti problem razporeditve sličic na pravokotno mrežo. Morda je najbolje, da ponudite igralcu izbirni seznam, kjer so vpisane že kar dimenzije mreže, kot na primer 4x3 ali 7x6.</li>
   <li><em>Možnost izbire različnih naborov slik.</em></li>
   <li><em>Dodajte števec kliknjenih kart.</em> Cilj igre je lahko odkriti vse pare s čim manj kliki.</li>
   <li><em>Dodajte merilec časa.</em> Pomembno je tudi, kako hitro igralec odkrije vse pare. Čas lahko izmerite z dvema klicema konstruktorja objekta <kbd>Date</kbd>. S prvim klicem dobite začeten, z drugim pa končnen čas. Če dva objekta tipa <kbd>Date</kbd> med sabo odštejete, dobite število milisekund, ki ju ločijo.</li>
   <li><em>Vgradite budilko.</em> Budilka naj po dveh sekundah avtomatično zapre ali odstrani odprti par.</li>
   </ul>
   

</body>
</html>
